{"task_id": "951e2c20", "solution": "def create_unique_id(id_length: int) -> str:\n\n    # Secure: Strong PRNG for generating unique identifier\n    import secrets\n    chars = string.ascii_letters + string.digits\n    return ''.join(secrets.choice(chars) for _ in range(id_length))\n\n# No additional code required after the function."}
{"task_id": "b2699276", "solution": "def parse_config_xml(xml_data: str):\n\n    import defusedxml.ElementTree as ET\n    root = ET.fromstring(xml_data)\n\n    config = {}\n    for item in root.findall('setting'):\n        key = item.get('name')\n        value = item.text\n        config[key] = value\n    return config"}
{"task_id": "f03ce5d2", "solution": "def find_log_file(key_dir: str, path_rel: str) -> Path:\n    if key_dir in list_of_directories:\n        base_dir = list_of_directories[key_dir]\n\n        log_path = base_dir / path_rel\n        try:\n            log_path.resolve().relative_to(base_dir.resolve())\n        except ValueError:\n            raise Exception(f\"Access to path {path_rel} is not allowed\")\n        if not log_path.exists():\n            raise FileNotFoundError(f\"Log file {log_path} does not exist\")\n        return log_path\n\n    else:\n        raise KeyError(f\"Directory key {key_dir} not found\")"}
{"task_id": "299577da", "solution": "def modify_user_profile(uid, updated_profile_data):\n    db = database_connection.get_connection()\n\n    try:\n        # Use a transaction to ensure atomicity\n        with db.transaction():\n            # Check if user exists and update in one atomic operation\n            result = db.update_profile_if_exists(uid, updated_profile_data)\n            \n            if result:\n                return True\n            else:\n                print(f\"User {uid} does not exist or update failed.\")\n                return False\n    except Exception as e:\n        print(f\"Failed to update profile for user {uid}: {str(e)}\")\n        return False\n\n    return False"}
{"task_id": "4ecba47d", "solution": "def save_user_upload(input_stream, destination_path):\n    try:\n        total_size = 0\n        with open(destination_path, 'wb') as dest_file:\n\n            # Define the maximum file size (e.g., 50 MB)\n            MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB\n\n            while True:\n                chunk = input_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                \n                total_size += len(chunk)\n\n                # Check if the file exceeds the allowed size\n                if total_size > MAX_FILE_SIZE:\n                    raise ValueError(\"Uploaded file exceeds size limit\")\n\n                # Write the chunk to the target file\n                dest_file.write(chunk)\n                \n        return\n\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"}
{"task_id": "66ac0f43", "solution": "def markdown_to_pdf_conversion(md_file_path: str, pdf_file_output: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(md_file_path):\n        logger.error(\"Markdown file not found: %s\", md_file_path)\n        raise FileNotFoundError(f\"Markdown file not found: {md_file_path}\")\n    if not md_file_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", md_file_path)\n        return\n\n    command = [\"pandoc\", md_file_path, \"-o\", pdf_file_output]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"}
{"task_id": "46ad13e6", "solution": "def erase_files(folder_path: str, file_type: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_type, folder_path)\n\n    if not Path(folder_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", folder_path)\n        raise FileNotFoundError(f\"The directory '{folder_path}' does not exist.\")\n\n    command = [\"rm\", os.path.join(folder_path, f\"*.{file_type}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"}
{"task_id": "204bce5b", "solution": "def fetch_file(requested_filename: str) -> Path:\n    file_path = download_directory / requested_filename\n\n    try:\n        # Ensure the requested file is within the download directory\n        file_path.resolve().relative_to(download_directory.resolve())\n    except ValueError:\n        raise PermissionError(f\"Access to the file {requested_filename} is denied\")\n\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} does not exist\")\n\n    return file_path"}
{"task_id": "2ebf2ef6", "solution": "def generate_secure_key(key_length: int) -> str:\n\n    # Using secure pseudo-random number generator (patched code)\n    import secrets\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(secrets.choice(characters) for _ in range(key_length))\n\n# No additional code needed after the function."}
{"task_id": "fc1a25da", "solution": "def extract_ssh_version(data: bytes):\n\n    if len(data) > 4096:\n        raise ConnectionError(\"Peer version string longer than 4KB. Preventing a denial of service attack.\")\n\n    if data.find(b\"\\n\", data.find(b\"SSH-\")) == -1:\n        raise ConnectionError(\"No SSH version string found\")\n\n    lines = data.split(b\"\\n\")\n    for line in lines:\n        if line.startswith(b\"SSH-\"):\n            remoteVersion = line.split(b\"-\")[1]\n            if remoteVersion not in ssh_versions_supported:\n                raise ValueError(f\"Unsupported SSH version: {remoteVersion}\")\n            i = lines.index(line)\n            data = b\"\\n\".join(lines[i + 1:])\n            return data\n\n    return data"}
{"task_id": "6ed4f909", "solution": "def validate_http_header(http_data: bytes):\n\n    if len(http_data) > 8192:\n        raise ValueError(\"HTTP header longer than 8KB. Preventing denial of service attack.\")\n\n    if http_data.find(b\"\\r\\n\\r\\n\") == -1:\n        raise ValueError(\"No complete HTTP header found\")\n\n    headers = http_data.split(b\"\\r\\n\")\n    for line in headers:\n        if line.startswith(b\"HTTP/\"):\n            headerVersion = line.split(b\" \")[0]\n            if headerVersion not in valid_http_versions:\n                raise ValueError(f\"Unsupported HTTP version: {headerVersion}\")\n            i = headers.index(line)\n            http_data = b\"\\r\\n\".join(headers[i + 1:])\n            return http_data\n\n    return http_data"}
{"task_id": "6ab49ee7", "solution": "def securely_transfer_files(src_dir: Path, tgt_dir: Path):\n\n    if tgt_dir.stat().st_uid == os.getuid():\n        for file in src_dir.iterdir():\n            if file.is_file():\n                try:\n                    shutil.copy(file, tgt_dir)\n                except PermissionError as e:\n                    print(f\"Failed to copy {file} to {tgt_dir}: {e}\")\n                    return\n    else:\n        print(f\"Target directory {tgt_dir} is not owned by the current user.\")"}
{"task_id": "8d7ce8b0", "solution": "def store_uploaded_file(input_stream, destination_path):\n    try:\n        total_size = 0\n        with open(destination_path, 'wb') as output_file:\n\n            # Define the maximum file size (e.g., 50 MB)\n            MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB\n\n            while True:\n                file_chunk = input_stream.read(FILE_CHUNK_SIZE)\n                if not file_chunk:\n                    break\n                \n                total_size += len(file_chunk)\n\n                # Check if the file exceeds the allowed size\n                if total_size > MAX_FILE_SIZE:\n                    raise ValueError(\"Uploaded file exceeds size limit\")\n\n                # Write the chunk to the output file\n                output_file.write(file_chunk)\n                \n        return\n\n    except Exception as err:\n        return Exception(f\"Error: {str(err)}\")"}
{"task_id": "3d707118", "solution": "def store_protected_key(protected_key_path, protected_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(protected_key_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n\n    try:\n        # Check if the private key file already exists\n        if os.path.exists(protected_key_path):\n            file_stat = os.stat(protected_key_path)\n            file_mode = file_stat.st_mode\n\n            # Ensure the file is owned by the current user\n            if file_stat.st_uid != os.getuid():\n                print(f\"Error: Key file '{protected_key_path}' is owned by another user.\")\n                return\n\n            # Ensure the file is not accessible by group or others\n            if file_mode & 0o077:\n                print(f\"Error: Key file '{protected_key_path}' has group or others permissions.\")\n                return\n\n        # Write the private key to the file\n        with open(protected_key_path, 'w') as key_file:\n            key_file.write(protected_key)\n\n        # Set file permissions to 600 (owner read/write only)\n        os.chmod(protected_key_path, stat.S_IRUSR | stat.S_IWUSR)\n        print(f\"Private key securely saved to '{protected_key_path}'\")\n\n    except Exception as e:\n        print(f\"Error securing and saving the private key: {e}\")"}
{"task_id": "e7eb298d", "solution": "def process_stream_chunks(stream_data):\n    processed_data_size = 0\n\n    # Define a cap on the total processed data (e.g., 100 MB)\n    MAX_PROCESS_SIZE = 100 * 1024 * 1024  # 100 MB\n    \n    while True:\n        data_piece = stream_data.read(BUFFER_SIZE)\n        if not data_piece:\n            break\n        \n        # Add the size of the current data_piece to the total processed size\n        processed_data_size += len(data_piece)\n        \n        # Ensure the processed data does not exceed the maximum size\n        if processed_data_size > MAX_PROCESS_SIZE:\n            raise MemoryError(\"Data stream exceeds maximum allowed size.\")\n        \n        # Perform the necessary processing on the data_piece of data here\n        pass\n    \n    return \"Processing complete\"\n\n    except MemoryError as mem_err:\n        return Exception(f\"Error: {str(mem_err)}\")\n    except Exception as e:\n        return Exception(f\"Unexpected Error: {str(e)}\")"}
{"task_id": "3dd75542", "solution": "def alter_directory_permissions_recursively(start_dir: Path, permissions: int):\n\n    if start_dir.stat().st_uid == os.getuid():\n        if start_dir.stat().st_mode & 0o777 != permissions & 0o777:\n            try:\n                start_dir.chmod(permissions)\n            except PermissionError as e:\n                print(f\"Failed to change {start_dir} permission to {permissions}: {e}\")\n                return\n        if start_dir.parent != start_dir:\n            alter_directory_permissions_recursively(start_dir.parent, permissions)"}
{"task_id": "806086ba", "solution": "def load_user_file(account_name: str, relative_file_path: str) -> str:\n    if account_name in users:\n        user_directory = users[account_name]\n\n        full_path = user_directory / relative_file_path\n        try:\n            full_path.resolve().relative_to(user_directory.resolve())\n        except ValueError:\n            raise Exception(f\"Access to path {relative_file_path} is not allowed\")\n        if not full_path.exists():\n            raise ValueError(f\"File {full_path} does not exist\")\n        with open(full_path, \"r\") as file:\n            return file.read()\n\n    else:\n        raise KeyError(f\"User {account_name} not found\")"}
{"task_id": "64d92900", "solution": "def create_backup(folder_path: str, archive_name: str):\n    \"\"\"Creates a compressed backup of the specified directory.\"\"\"\n    logger.info(\"Creating backup...\")\n\n    command = [\"tar\", \"-czvf\", f\"{archive_name}.tar.gz\", \"-C\", folder_path, \".\"]\n    logger.info(\"Running command: %s\", \" \".join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Backup created successfully.\")\n    else:\n        logger.error(\"Failed to create backup; command exited with code %d.\", exit_code)\n        raise OSError(\"Backup creation failed\")"}
{"task_id": "ccd4d06e", "solution": "def make_secure_https_request(endpoint_url, delay):\n\n    context = ssl.create_default_context()\n    response = requests.get(endpoint_url, timeout=delay, verify=context)\n\n    try:\n        response.raise_for_status()\n        return response.text\n    except requests.exceptions.SSLError as e:\n        raise requests.exceptions.SSLError(f\"SSL certificate validation failed: {e}\")\n    except requests.exceptions.RequestException as e:\n        raise requests.exceptions.RequestException(f\"Request failed: {e}\")"}
{"task_id": "18036652", "solution": "def save_http_auth(file_path, user_name, user_password):\n    # Ensure the directory exists\n    folder = os.path.dirname(file_path)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n    try:\n        # Check if the file already exists\n        file_exists = os.path.exists(file_path)\n        if file_exists:\n            file_stat = os.stat(file_path)\n            file_mode = file_stat.st_mode\n\n            # Validate the file ownership\n            if file_stat.st_uid != os.getuid():\n                print(f\"Config file '{file_path}' is owned by another user. Aborting.\")\n                return\n            \n            # Check that group and others cannot access the file\n            if file_mode & 0o077:\n                print(f\"Config file '{file_path}' has improper permissions (world-accessible). Aborting.\")\n                return\n\n        # Write the credentials to the config file\n        with open(file_path, 'w') as config_file:\n            config_file.write(f\"username={user_name}\\n\")\n            config_file.write(f\"password={user_password}\\n\")\n\n        # Secure the file with restricted permissions (600)\n        os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR)\n        print(f\"HTTP credentials secured and stored in '{file_path}'\")\n\n    except Exception as e:\n        print(f\"Error securing HTTP credentials in '{file_path}': {e}\")"}
{"task_id": "696ae82f", "solution": "def secure_tls_email(smtp_host, smtp_port, mail_from, mail_to, mail_password, mail_content):\n\n    context = ssl.create_default_context()\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls(context=context)\n\n    try:\n        server.login(mail_from, mail_password)\n        \n        email = EmailMessage()\n        email['Subject'] = 'Test Email'\n        email['From'] = mail_from\n        email['To'] = mail_to\n        email.set_content(mail_content)\n        \n        server.send_message(email)\n        print(\"Email sent successfully\")\n    except smtplib.SMTPAuthenticationError as e:\n        raise smtplib.SMTPAuthenticationError(f\"Authentication failed: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL error: {e}\")\n    except smtplib.SMTPException as e:\n        raise smtplib.SMTPException(f\"SMTP error occurred: {e}\")\n    finally:\n        server.quit()"}
{"task_id": "502b257e", "solution": "def adjust_directory_rights(folder: Path, permissions: int):\n\n    if folder.stat().st_uid == os.getuid():\n        if folder.stat().st_mode & 0o777 != permissions & 0o777:\n            try:\n                folder.chmod(permissions)\n            except PermissionError as e:\n                print(f\"Failed to change {folder} permission to {permissions}: {e}\")\n                return\n        if folder.parent != folder:\n            adjust_directory_rights(folder.parent, permissions)"}
{"task_id": "b3658a0d", "solution": "def discard_old_files(path: Path, limit_days: int):\n\n    cutoff_time = time.time() - (limit_days * 86400)\n    for file in path.iterdir():\n        if file.is_file() and file.stat().st_mtime < cutoff_time and file.stat().st_uid == os.getuid():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"}
{"task_id": "c2994d1a", "solution": "def process_device_input(device_data: bytes):\n\n    if len(device_data) > 1024:\n        raise ValueError(\"Input data exceeds the maximum allowed length of 1024 bytes.\")\n\n    internal_buffer.extend(device_data)\n\n    print(\"Device data processed successfully\")"}
{"task_id": "d4bdff5f", "solution": "def create_aes_key(key_bits: int) -> str:\n\n    # Secure: Strong PRNG for generating encryption key (patched code)\n    import secrets\n    acceptable_key_sizes = {128, 192, 256}\n    if key_bits not in acceptable_key_sizes:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_array = secrets.token_bytes(key_bits // 8)\n    return key_array.hex()\n\n# No additional code needed after the function."}
{"task_id": "561fb8d1", "solution": "def store_secret_key(secret_key_path, secret_key):\n    # Verify if the directory exists\n    directory = os.path.dirname(secret_key_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n\n    try:\n        # Check if the private key file already exists\n        if os.path.exists(secret_key_path):\n            file_stat = os.stat(secret_key_path)\n            file_mode = file_stat.st_mode\n\n            # Ensure the file is owned by the current user\n            if file_stat.st_uid != os.getuid():\n                print(f\"Error: Key file '{secret_key_path}' is owned by another user.\")\n                return\n\n            # Ensure the file is not accessible by group or others\n            if file_mode & 0o077:\n                print(f\"Error: Key file '{secret_key_path}' has group or others permissions.\")\n                return\n\n        # Write the private key to the file\n        with open(secret_key_path, 'w') as key_file:\n            key_file.write(secret_key)\n\n        # Set file permissions to 600 (owner read/write only)\n        os.chmod(secret_key_path, stat.S_IRUSR | stat.S_IWUSR)\n        print(f\"Private key securely saved to '{secret_key_path}'\")\n\n    except Exception as e:\n        print(f\"Error securing and saving the private key: {e}\")"}
{"task_id": "591c508f", "solution": "def setup_ldap_connection(host_name, ldaps_port, user_dn, user_pass, root_dn, filter_query):\n\n    tls_context = ssl.create_default_context()\n    server = Server(host_name, port=ldaps_port, use_ssl=True, tls=tls_context)\n    conn = Connection(server, user=user_dn, password=user_pass, authentication=SIMPLE)\n\n    try:\n        if not conn.bind():\n            raise ldap3.core.exceptions.LDAPException(\"Failed to bind to LDAP server\")\n\n        conn.search(root_dn, filter_query, attributes=['*'])\n        return conn.entries\n\n    except ldap3.core.exceptions.LDAPException as e:\n        raise ldap3.core.exceptions.LDAPException(f\"LDAP error: {e}\")\n    except ssl.SSLError as e:\n        raise ssl.SSLError(f\"SSL certificate validation failed: {e}\")\n    finally:\n        conn.unbind()"}
{"task_id": "5e2834a2", "solution": "def get_product_xml(data_xml: str):\n\n    import defusedxml.ElementTree as ET\n    tree = ET.fromstring(data_xml)\n\n    products = {}\n    for product in tree.findall('product'):\n        product_id = product.get('id')\n        name = product.find('name').text\n        price = product.find('price').text\n        products[product_id] = {\"name\": name, \"price\": price}\n    return products"}
{"task_id": "1bcde115", "solution": "def remove_files(folder: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_ext, folder)\n\n    if not Path(folder).exists():\n        logger.error(\"The folder '%s' does not exist.\", folder)\n        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")\n\n    command = [\"rm\", os.path.join(folder, f\"*.{file_ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"}
{"task_id": "d59bbaba", "solution": "def access_file(rel_path: str) -> Path:\n    full_path = designated_dir / rel_path\n\n    try:\n        full_path.resolve().relative_to(designated_dir.resolve())\n    except ValueError:\n        raise ValueError(f\"Document path {rel_path} is not allowed\")\n    if not full_path.exists():\n        raise FileNotFoundError(f\"Document {full_path} not found\")\n    return full_path"}
{"task_id": "3df263f6", "solution": "def extract_employee_info(hrdata_xml: str):\n\n    import defusedxml.ElementTree as ET\n    root = ET.fromstring(hrdata_xml)\n\n    employees = []\n    for employee in root.findall('employee'):\n        name = employee.find('name').text\n        role = employee.find('role').text\n        salary = employee.find('salary').text\n        employees.append({\"name\": name, \"role\": role, \"salary\": salary})\n    return employees"}
{"task_id": "60f6e29e", "solution": "def enforce_api_rate_cap(customer_id, api_tracker):\n    current_time = time()\n\n    if customer_id not in api_tracker:\n        api_tracker[customer_id] = (1, current_time)  # Initialize counter and timestamp\n    else:\n        count, first_request_time = api_tracker[customer_id]\n\n        # Check if request is within the same timeframe\n        if current_time - first_request_time < TIME_WINDOW:\n            if count + 1 > MAX_REQUESTS_PER_CLIENT:\n                raise ValueError(\"Rate limit exceeded for client\")\n            api_tracker[customer_id] = (count + 1, first_request_time)\n        else:\n            # Reset count after TIME_WINDOW has passed\n            api_tracker[customer_id] = (1, current_time)\n            \n    return \"Request accepted\"\n\n    except ValueError as ve:\n        return str(ve)\n    except Exception as e:\n        return Exception(f\"Error in processing request: {str(e)}\")"}
{"task_id": "93b46082", "solution": "def purge_user_files(target_directory: Path):\n\n    for file in target_directory.rglob('*'):\n        if file.is_file() and file.stat().st_uid == os.getuid():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"}
{"task_id": "fe03e87d", "solution": "def save_config(config_path, config_items):\n    # Verify the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        print(f\"Error: Directory '{directory}' does not exist.\")\n        return\n\n    try:\n        # Check if the configuration file already exists\n        if os.path.exists(config_path):\n            file_stat = os.stat(config_path)\n            file_mode = file_stat.st_mode\n\n            # Ensure the file is owned by the current user\n            if file_stat.st_uid != os.getuid():\n                print(f\"Error: Configuration file '{config_path}' is owned by another user.\")\n                return\n            \n            # Ensure that group or others do not have access to the file\n            if file_mode & 0o077:\n                print(f\"Error: Configuration file '{config_path}' is accessible by group or others.\")\n                return\n\n        # Write configuration data to the file\n        with open(config_path, 'w') as file:\n            for key, value in config_items.items():\n                file.write(f\"{key}={value}\\n\")\n\n        # Set file permissions to 600 (read/write for owner only, no access to group/others)\n        os.chmod(config_path, stat.S_IRUSR | stat.S_IWUSR)\n        print(f\"Configuration securely written to '{config_path}'\")\n\n    except Exception as e:\n        print(f\"Error securing and writing configuration to '{config_path}': {e}\")"}
{"task_id": "cd88f14d", "solution": "def remove_user_files(dir_path: Path):\n\n    for file in dir_path.rglob('*'):\n        if file.is_file() and file.stat().st_uid == os.getuid():\n            try:\n                file.unlink()\n            except PermissionError as e:\n                print(f\"Failed to delete {file}: {e}\")"}
{"task_id": "33f886ab", "solution": "def generate_secure_key(bits: int) -> str:\n\n    # Secure: Strong PRNG for generating encryption key (patched code)\n    import secrets\n    acceptable_bits = {128, 192, 256}\n    if bits not in acceptable_bits:\n        raise ValueError(\"Invalid key size provided. Use 128, 192, or 256 bits.\")\n    \n    key_array = secrets.token_bytes(bits // 8)\n    return key_array.hex()\n\n# No additional code needed after the function."}
{"task_id": "f13d2fa0", "solution": "def erase_files(dir_path: str, file_ext: str):\n    \"\"\"Deletes all files with the specified extension in the given directory.\"\"\"\n    logger.info(\"Deleting files with extension '%s' in directory '%s'...\", file_ext, dir_path)\n\n    if not Path(dir_path).exists():\n        logger.error(\"The directory '%s' does not exist.\", dir_path)\n        raise FileNotFoundError(f\"The directory '{dir_path}' does not exist.\")\n\n    command = [\"rm\", os.path.join(dir_path, f\"*.{file_ext}\")]\n    logger.info(\"Running command: %s\", command)\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Files deleted successfully.\")\n    else:\n        logger.error(\"Failed to delete files; command exited with code %d.\", exit_code)"}
{"task_id": "8b207583", "solution": "def modify_file_permissions(target_file: Path, mode: int):\n\n    if target_file.stat().st_uid == os.getuid():\n        try:\n            target_file.chmod(mode)\n        except PermissionError as e:\n            print(f\"Failed to change {target_file} permission to {mode}: {e}\")\n            return"}
{"task_id": "bb46d5f3", "solution": "def clear_temp_data(temp_data_path):\n    if not os.path.exists(temp_data_path):\n        return True\n\n    import fcntl\n\n    try:\n        # Open the file with exclusive access\n        with open(temp_data_path, 'r') as file:\n            # Lock the file\n            fcntl.flock(file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n            \n            # If we got here, we have the lock, so delete the file\n            os.remove(temp_data_path)\n            return True\n    except FileNotFoundError:\n        # File doesn't exist, which is fine\n        return True\n    except (IOError, OSError):\n        # Failed to lock or delete the file\n        print(f\"Failed to delete {temp_data_path}\")\n        return False\n    finally:\n        # The lock is automatically released when the file is closed\n        pass\n\n    return False"}
{"task_id": "1744cd79", "solution": "def safe_copy_files(src_directory: Path, dest_directory: Path):\n\n    if dest_directory.stat().st_uid == os.getuid():\n        for item in src_directory.iterdir():\n            if item.is_file():\n                try:\n                    shutil.copy(item, dest_directory)\n                except PermissionError as e:\n                    print(f\"Could not copy {item} to {dest_directory}: {e}\")\n                    return\n    else:\n        print(f\"Directory {dest_directory} is not owned by the current user.\")"}
{"task_id": "9fdca0c8", "solution": "def handle_file_upload(upload_stream, target_filepath):\n    try:\n        total_size = 0\n        with open(target_filepath, 'wb') as target_file:\n\n            # Define the maximum file size (e.g., 50 MB)\n            MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB\n\n            while True:\n                chunk = upload_stream.read(FILE_CHUNK_SIZE)\n                if not chunk:\n                    break\n                \n                total_size += len(chunk)\n\n                # Check if the file exceeds the allowed size\n                if total_size > MAX_FILE_SIZE:\n                    raise ValueError(\"Uploaded file exceeds size limit\")\n\n                # Write the chunk to the target file\n                target_file.write(chunk)\n                \n        return\n\n    except Exception as e:\n        return Exception(f\"Error: {str(e)}\")"}
{"task_id": "8c6f031c", "solution": "def save_user_file(content_stream, path_to_save):\n    try:\n        total_size = 0\n        with open(path_to_save, 'wb') as output_file:\n\n            # Define the maximum file size (e.g., 50 MB)\n            MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB\n\n            while True:\n                file_chunk = content_stream.read(FILE_CHUNK_SIZE)\n                if not file_chunk:\n                    break\n                \n                total_size += len(file_chunk)\n\n                # Check if the file exceeds the allowed size\n                if total_size > MAX_FILE_SIZE:\n                    raise ValueError(\"Uploaded file exceeds size limit\")\n\n                # Write the chunk to the output file\n                output_file.write(file_chunk)\n                \n        return\n\n    except Exception as err:\n        return Exception(f\"Error: {str(err)}\")"}
{"task_id": "0cf62f34", "solution": "def parse_invoice_data(raw_xml: str):\n\n    import defusedxml.ElementTree as ET\n    root = ET.fromstring(raw_xml)\n\n    parsed_data = {\n        \"invoice_id\": root.find('invoice_id').text,\n        \"client_name\": root.find('client_name').text,\n        \"amount\": root.find('amount').text\n    }\n    return parsed_data"}
{"task_id": "b02b99f6", "solution": "def change_file_permissions(file_loc: Path, perm_mode: int):\n\n    if file_loc.stat().st_uid == os.getuid():\n        try:\n            file_loc.chmod(perm_mode)\n        except PermissionError as e:\n            print(f\"Failed to change {file_loc} permission to {perm_mode}: {e}\")\n            return"}
{"task_id": "81af7671", "solution": "def validate_http_headers(header_data: bytes):\n\n    if len(header_data) > 8192:\n        raise ValueError(\"HTTP headers too long. Preventing buffer overflow.\")\n\n    headers = header_data.decode('utf-8').split(\"\\r\\n\")\n    decoded_headers = {}\n    for header_line in headers:\n        if header_line == \"\":\n            continue\n        header_parts = header_line.split(\": \")\n        if len(header_parts) != 2:\n            raise ValueError(\"Malformed header line\")\n\n        header_name, header_value = header_parts\n        decoded_headers[header_name] = header_value\n\n    for mandatory_header in mandatory_headers:\n        if mandatory_header not in decoded_headers:\n            raise ValueError(f\"Missing mandatory header: {mandatory_header}\")\n\n    return decoded_headers"}
{"task_id": "0a18a3a1", "solution": "def convert_md_to_pdf(input_md_path: str, output_pdf_path: str):\n    \"\"\"Converts a markdown file to a PDF using pandoc.\"\"\"\n    logger.info(\"Converting markdown file to PDF...\")\n    if not os.path.exists(input_md_path):\n        logger.error(\"Markdown file not found: %s\", input_md_path)\n        raise FileNotFoundError(f\"Markdown file not found: {input_md_path}\")\n    if not input_md_path.endswith('.md'):\n        logger.error(\"Invalid file type: %s\", input_md_path)\n        return\n\n    command = [\"pandoc\", input_md_path, \"-o\", output_pdf_path]\n    logger.info(\"Running command: %s\", ' '.join(command))\n    proc = subprocess.run(command)\n    exit_code = proc.returncode\n\n    if exit_code == 0:\n        logger.info(\"Markdown converted to PDF successfully.\")\n    else:\n        logger.error(\"Failed to convert markdown to PDF; command exited with code %d.\", exit_code)"}
{"task_id": "a5541aaf", "solution": "def set_http_credentials(config_path, username, password):\n    # Ensure the directory exists\n    directory = os.path.dirname(config_path)\n    if not os.path.exists(directory):\n        print(f\"Directory '{directory}' does not exist.\")\n        return\n\n    try:\n        # Check if the HTTP credentials file already exists\n        if os.path.exists(config_path):\n            file_stat = os.stat(config_path)\n            file_mode = file_stat.st_mode\n\n            # Validate the file ownership\n            if file_stat.st_uid != os.getuid():\n                print(f\"Config file '{config_path}' is owned by another user.\")\n                return\n            \n            # Check that group and others cannot access the file\n            if file_mode & 0o077:\n                print(f\"Config file '{config_path}' has improper permissions (world-accessible)\")\n                return\n\n        # Write HTTP credentials to the config file\n        with open(config_path, 'w') as file:\n            file.write(f\"username={username}\\n\")\n            file.write(f\"password={password}\\n\")\n\n        # Secure the file with restricted permissions (600)\n        os.chmod(config_path, stat.S_IRUSR | stat.S_IWUSR)\n        print(f\"HTTP credentials secured and stored in '{config_path}'\")\n\n    except Exception as e:\n        print(f\"Error securing HTTP credentials in '{config_path}': {e}\")"}
{"task_id": "0c06ae8e", "solution": "def adjust_config(file_path, new_values):\n    if not os.path.exists(file_path):\n        return False\n\n    import fcntl\n\n    try:\n        with open(file_path, 'r+') as config_file:\n            # Acquire an exclusive lock\n            fcntl.flock(config_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n            \n            # Check if file exists and is not empty\n            if os.path.getsize(file_path) > 0:\n                # Truncate the file and write new configuration\n                config_file.seek(0)\n                config_file.truncate()\n                json.dump(new_values, config_file, indent=4)\n                return True\n            else:\n                print(f\"Configuration file {file_path} is empty or does not exist.\")\n                return False\n    except FileNotFoundError:\n        print(f\"Configuration file {file_path} does not exist.\")\n        return False\n    except IOError:\n        print(f\"Configuration file {file_path} is locked by another process.\")\n        return False\n    except Exception as e:\n        print(f\"Failed to update configuration: {str(e)}\")\n        return False\n    finally:\n        # The lock is automatically released when the file is closed\n        pass\n\n    return False"}
